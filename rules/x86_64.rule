+(_, 1) => (1) {
    mov %1, $1
    inc %1
    out %1
}

+(_, 2) => (1) {
    mov %1, $1
    add %1, 2
    out %1
}

+(_, _) => (2) {
    // Move first parameter to virtual register and then
    // add the second parameter to it.
    mov %1, $1
    add %1, $2
    out %1
}

-(_, 1) => (1) {
    mov %1, $1
    dec %1
    out %1
}

-(_, 2) => (1) {
    mov %1, $1
    sub %1, 2
    out %1
}

<(_, _) => (0) {
}

Î¦(_, _) => (0) {
    phi %1, $1, $2
    out %1
}

:=(_) => (0) {
    out $1
}

PROJ(CALL(_, _, _), 0) => (0) {
}

PROJ(_, 1) => (0) {
    out $1
}

CALL(_, _, _) => (5) {
    out %rax
}

// Weird edge cases, don't emit anything in this case.
COPYTOREG(_, START) => (0) {
}
COPYTOREG(_, PROJ(CALL(_, _, _), 0)) => (0) {
}

COPYTOREG(_, _) => (1) {
    // For COPYTOREG, the register name is the first parameter.
    mov $1, $3
}

COPYFROMREG(_) => (0) {
    // For COPYFROMREG, the register name is the first parameter
    mov %1, $1
    out %1
}

GOTO(_) => (1) {
    goto $1
}

START => (0) {
}

// pattern for handling immediates.
CONST => (1) {
    // For CONST, the first parameter is itself as an immediate.
    mov %1, $1
    out %1
}